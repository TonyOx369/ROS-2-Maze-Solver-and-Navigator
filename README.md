# ROS 2 Maze Solver and Navigator

This ROS 2 package implements a complete autonomous navigation solution for a robot in a known maze environment. It uses the A* algorithm to find the shortest path, smooths the resulting trajectory, and employs a controller to follow the path from a given entry to an exit point.

***

## Features

-   **Map Inflation**: Inflates obstacles in the occupancy grid to create a safety margin for the robot.
-   **A\* Path Planning**: Implements the A\* search algorithm to find an optimal path through the inflated map.
-   **Path Smoothing**: Simplifies the raw A\* path by removing redundant waypoints, resulting in a smoother trajectory.
-   **Pure Pursuit Controller**: A simple and effective controller follows the smoothed path using a lookahead distance.
-   **Dynamic Velocity Scaling**: The robot automatically slows down when making sharp turns for improved stability.
-   **Full Visualization**: Publishes all relevant data (inflated map, planned path, smoothed path, actual path) for easy debugging and visualization in RViz.

***

## Node Details

### Subscribed Topics

| Topic Name           | Message Type                        | Description                                     |
| -------------------- | ----------------------------------- | ----------------------------------------------- |
| `/virya_test/map`    | `nav_msgs/msg/OccupancyGrid`        | The static map of the maze environment.         |
| `/virya_test/entry`  | `geometry_msgs/msg/PoseStamped`     | The starting position and orientation for the robot. |
| `/virya_test/exit`   | `geometry_msgs/msg/PoseStamped`     | The target destination for the robot.             |
| `/virya_test/odom`   | `nav_msgs/msg/Odometry`             | The robot's current pose and velocity from odometry. |

### Published Topics

| Topic Name         | Message Type                        | Description                                                  |
| ------------------ | ----------------------------------- | ------------------------------------------------------------ |
| `/cmd_vel`         | `geometry_msgs/msg/TwistStamped`    | Velocity commands sent to the robot's base controller.       |
| `/inflated_map`    | `nav_msgs/msg/OccupancyGrid`        | The map with obstacles inflated for safer path planning.     |
| `/planned_path`    | `nav_msgs/msg/Path`                 | The raw, grid-based path generated by the A\* algorithm.     |
| `/smoothed_path`   | `nav_msgs/msg/Path`                 | The simplified, smoother path that the robot will follow.    |
| `/actual_path`     | `nav_msgs/msg/Path`                 | The history of the robot's actual odometry poses.            |

***

## How to Build and Run

1.  **Create a workspace**
    ```bash
    mkdir -p ~/ros2_ws/src
    ```
2. **Clone this repository in your workspace**
    ```bash
    cd ~/ros2_ws/src
    git clone https://github.com/TonyOx369/ROS-2-Maze-Solver-and-Navigator.git
    ```

3.  **Build the Workspace**: Navigate to the root of your workspace and build the package using `colcon`.
    ```bash
    cd ~/ros2_ws
    colcon build --symlink-install
    ```

4.  **Source the Environment**: In every new terminal you open, you must source the workspace to make ROS 2 aware of your executable.
    ```bash
    source ~/ros2_ws/install/setup.bash
    ```
5. **Export the turtlebot model and launch the turtlebot in the Maze environment**
   ```bash
    export TURTLEBOT3_MODEL=burger
    ros2 launch turtlebot3_gazebo virya_test.launch.py 
    ```

6.  **Run the Node**: Launch the maze solver node.
    ```bash
    ros2 run maze_solver maze_solver_node
    ```

***

## Usage Workflow

The node will start and wait for the required initial data. To begin navigation, you must publish messages to the following topics (usually from another node, a script, or the command line):

1.  A `nav_msgs/msg/OccupancyGrid` message to `/virya_test/map`.
2.  A `geometry_msgs/msg/PoseStamped` message to `/virya_test/entry`.
3.  A `geometry_msgs/msg/PoseStamped` message to `/virya_test/exit`.

Once all three messages are received, the node will automatically perform the following sequence:
1.  Inflate the map.
2.  Plan the path using A\*.
3.  Smooth the path.
4.  Begin publishing `/cmd_vel` messages to follow the path.

***

## Visualization in RViz

To see the robot's plan and progress, launch RViz and add the following displays:

1.  **Map**:
    -   Topic: `/virya_test/map` (or `/inflated_map` to see the inflated version)
2.  **Path** (Add multiple Path displays):
    -   Topic: `/planned_path` (to see the A\* path)
    -   Topic: `/smoothed_path` (to see the path the robot follows)
    -   Topic: `/actual_path` (to see where the robot has been)
3.  **RobotModel** or **TF**: To visualize the robot's current position based on the TF tree.

Ensure your **Fixed Frame** in RViz is set to `map`.

https://github.com/user-attachments/assets/dc1a7c17-af69-4079-b871-705f4548e041




